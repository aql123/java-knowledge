package D_03_单例模式.L2_饿汉式单例;

/**
 * 避免了线程不安全，延迟加载，效率高。
 * 内部类式中，实现了延迟加载，当 【静态内部类懒加载饿汉式单例】 被加载时，其内部类不会被初始化，即 【静态内部类懒加载饿汉式单例】 被加载到 JVM 的时候，不会初始化单例类。只有我们调用了 getInstance(), 才会加载 【静态内部类】 创建唯一的实例 INSTANCE 到内存中. 并且也解决了懒汉式中多线程的问题。
 *
 * 原理：利用 JVM “类初始化时机” 延迟加载。
 *
 * 类初始化时机，只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：
 * –    创建类的实例，也就是 new 的方式
 * –    访问某个类或接口的静态变量，或者对该静态变量赋值
 * –    调用类的静态方法
 * –    反射，如 Class.forName()
 * –    初始化某个类的子类，则其父类也会被初始化
 * –    Java 虚拟机启动时被标明为启动类的类（Java Test），直接使用 java.exe 命令来运行某个主类
 */
public class P3_静态内部类懒加载饿汉式单例 {

    private P3_静态内部类懒加载饿汉式单例() {
    }

    private static class 静态内部类 {
        private final static P3_静态内部类懒加载饿汉式单例 INSTANCE = new P3_静态内部类懒加载饿汉式单例();
    }

    /**
     * 只有调用该方法，才有 new 的方式创建类的示例
     * 只有调用该方法，才有 访问某个类或接口的静态变量，或者对该静态变量赋值
     * 基于上面两种情况，延迟加载实现是 只有调用该方法，JVM 才会加载 静态内部类
     */
    public static P3_静态内部类懒加载饿汉式单例 getInstance() {
        return 静态内部类.INSTANCE;
    }

}
